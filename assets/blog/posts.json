[{"id":4,"titleDE":"Mein Mac Entwickler setup","titleEN":"My Mac developer setup","descDE":"Welche Entwicklertools kommen bei mir als erstes auf einen neuen Mac","descEN":"Which developer tools I install first on a new Mac","date":"2022-07-15T00:00:00.700Z","contentDE":"Bei einem neuen, oder neu aufgesetzten Mac müssen natürlich als Erstes alle Entwicklertools installiert werden.\nZunächst eine Liste meiner Lieblings-Tools. Danach gibt es noch Tipps und Terminal-Befehle, welche das Leben erleichtern.  \nDie Aufzählung ist natürlich nicht vollständig und jeder hat andere Favoriten. Wahrscheinlich hat sich mein Setup auch schon wieder etwas verändert. \n<br>\n\n## Terminal\n- brew\n- iTerm2\n- ohmyzsh\n- Powerlevel10k\n\n<br>  \n\n## Entwicklertools\n- JetBrains Toolbox\n- Intellij\n- Visual Studio Code\n- Redis\n- PostgreSQL (Postgres.app)\n- NodeJS\n- Angular\n- Fork (git client)\n- LanScan\n- Docker\n- Colima (Docker runtime)\n- Atom\n- Insomnia\n- draw.io\n\n<br>\n\n## Tools\n- Alfred\n- Magnet\n- Firefox\n\n<br>\n\n# Setup\n## brew  \n[Webseite](https://brew.sh)  \n\nDer Paketmanager für macOS. Mit brew werden wir die meisten weitern Tools installieren.\n\n``` bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```  \n<br>\n\n**Hinweis**: Auf Macs mit Apple Silicon wird brew jetzt hier installiert  \n`/opt/homebrew/bin`  \nund nicht wie bei Intel Macs hier  \n`/usr/local/bin`  \nDa der neue Pfad nicht in der PATH ist, muss dieser noch gesetzt werden.  \nDie folgende Zeile dafür einfach in `~/.zshrc` hinzufügen:  \n```\nexport PATH=/opt/homebrew/bin:$PATH\n```\n\n<br>\n\n## iTerm  \n[Webseite](https://iterm2.com)  \n\nMein Lieblingsterminal (Geschmacksache)\n\n```bash\nbrew install --cask iterm2\n```\n\n<br>\n\n## ohmyzsh\n[Webseite](https://ohmyz.sh/)  \n\nFramework für ZSH Konfiguration\n\n```bash\nsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n\n<br>\n\n## Powerlevel10k & zsh Tweaks \n<br>\n\n### Powerlevel10k\n[Webseite](https://github.com/romkatv/powerlevel10k)  \n\nRepository klonen:\n\n```bash\ngit clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k\n```\n\nZsh `~/.zshrc` Konfiguration editieren und als ZSH_THEME folgendes setzen: `ZSH_THEME=\"powerlevel10k/powerlevel10k\"`\n\nDanach eine neue Terminal Session starten damit die Änderungen angenommen werden.\nIn dieser neuen Session kann powerlevel10k konfiguriert werden. Die Konfiguration kann mit dem Befehl `p10k configure` erneut gestartet werden.\n\n<br>\n\n### Natural Text Editing\nDamit man in iTerm wie gewohnt mit option/alt + → oder ← über Wörter springen kann, ist es notwendig das in den Einstellungen zu aktivieren.  \n\n<br>\n\niTerm->Preferences...->Profiles->Keys->Key Mappings->Presets...->Natural Text Editing\n\n<br>\n\n### zsh autosuggestions\nInstallation:\n```bash\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n```\n\nKonfiguartion von `~/.zshrc` anpassen und `zsh-autosuggestions` zu Plugins hinzufügen:  \n`plugins=(zsh-autosuggestions)` \n\n![zsh-syntax-highlighting](/assets/img/blog/0004/zsh-autosuggestions.png)\n\n<br>\n\n## Redis\n[Webseite](https://redis.io/)\n\n<br>\n\n### Redis installieren\n```bash\nbrew install redis\n```\n\n<br>\n\n### Redis als vordergund Prozess starten\n\n```bash\nredis-server\n```\n\n<br>\n\n### Redis Service Kommandos\n\nNormalerweise **port 6379**  \n\n<br>\n\n**Start Redis Service**\n\n```bash\nbrew services start redis\n```\n\n**Stop Redis Service**\n\n```bash\nbrew services stop redis\n```\n\n**Restart Redis Service**\n\n```bash\nbrew services restart redis\n```\n\n<br>\n\n## PostgreSQL (Postgres.app)\n[Webpage](https://postgresapp.com/)  \nEinfachster Weg ohne große Einrichtung eine PostgeSQL Datenbank lokal auf dem Mac zum laufen zu bringen.  \nDownload über die Webseite.\n\n\n<br>\n\n## NodeJS\n[Webseite](https://nodejs.org)  \n\nInstalliert die latest Version von `node` und `npm`. Das ist __nicht__ die LTS Version!\n\n```bash\nbrew install node\n```\n\nUm die LTS Version zu installieren müssen wir die auf der NodeJS Webseite raussuchen und mit folgendem Befehl installieren. Dabei muss __X__ mit der Major Version der LTS ersetzt werden. z.B. `node@12`\n\n```bash\nbrew install node@X\n```\n\nUm zwischen verschieden NodeJS Versionen zu wechseln sind die folgenden Befehle notwendig:\n\n```bash\n# Verknüpfungen auf aktuelle Version entfernen\nbrew unlink node\n\n# Gewünschte Version installieren\nbrew install node@X\n\n# Gewünschte Version linken\nbrew link node@X\n\n# Testen ob alles geklappt hat\nnode --version\n```\n\n<br>\n\n## Angular\n[Webseite](https://angular.io)\n```bash\nnpm install -g @angular/cli\n```\n\n<br>\n\n## JetBrains Toolbox\n[Webseite](https://www.jetbrains.com/toolbox-app/)\n\nJetBrains Toolbox lebt in der Menüleiste auf dem Mac. Mit diesem Tool lassen sich alle JetBrains Programme einfach installieren und updaten. Zusätzlich gibt es eine Übersicht über die zuletzt geöffneten Projekte in allen JetBrains IDEs und öffnet diese in der korrekten IDE.\n\n![jetbrains toolbox](/assets/img/blog/0004/toolbox.png)\n\n```bash\nbrew install --cask jetbrains-toolbox\n```\n\n<br>\n\n## Visual Studio Code\n[Webseite](https://code.visualstudio.com/)  \n\n```bash\nbrew install --cask visual-studio-code\n```\n\n<br>\n\n## Fork\n[Webseite](https://git-fork.com)  \n\nSchöner und übersichtlicher git client für Windows und Mac.\n\n```bash\nbrew install --cask fork\n```\n\n<br>\n\n## LanScan\n[Webseite](https://apps.apple.com/de/app/lanscan/id472226235?mt=12)  \n\nKleines Tool zum scannen des LAN. Download im App Store.  \n\n![lanscan](/assets/img/blog/0004/lanscan.png)\n\n<br>\n\n## Docker\n[Webseite](https://www.docker.com/)  \n\n```bash\nbrew install docker\n```\n\n### Colima - Docker runtime\n[Webpage](https://github.com/abiosoft/colima)  \n\n```bash\nbrew install colima\n```\n\n<br>\n\n## Atom\n[Webseite](https://atom.io/)  \n\nPraktischer schlanker Texteditor mit riesigen Erweiterungsmöglichkeiten durch unzählige Plugins. Gut zum Editieren von Textdateien, ohne extra eine große IDE starten zu müssen.\n\n```bash\nbrew install --cask atom\n```\n\n<br>\n\n## Insomnia\n[Webseite](https://insomnia.rest)  \n\nInsomnia ist ein HTTP request Tool für REST APIs ähnlich Postman.\n\n```bash\nbrew install --cask insomnia\n```\n\n<br>\n\n## draw.io\n[Webseite](https://drawio-app.com/)  \n\nPraktisches Tool zum Zeichnen von Klassen- bis ER-Diagrammen.  \n\n```bash\nbrew install --cask drawio\n```\n\n<br>\n\n## MacDown\n[Webseite](https://macdown.uranusjr.com)  \n\nMarkdown editor.  \n\n```bash\nbrew install --cask macdown\n```\n\n<br>\n\n## Alfred\n[Webseite](https://www.alfredapp.com)  \n\nSpotlight alternative mit mehr Funktionen\n\n```bash\nbrew install --cask alfred\n```\n\n<br>\n\n## Magnet\n[Webseite](https://apps.apple.com/de/app/magnet/id441258766?mt=12) 3,99€ - Download im Mac App Store  \n<br>\nMagnet lebt in der Menüleiste von macOS und erweitert die Fenster Management Funktionen von macOS. Besonders gefallen mir bei Magnet die Shortcuts und die Möglichkeit meinen Bildschirm sowohl halbieren als auch dritteln zu können.  \nEs gibt einige dieser Tools, darunter auch einginge kostenlose. Da ich mich inzwischen aber an die Shortcuts von Magnet gewöhnt habe sind es mir die 3,99€ wert.\n\n![magnet](/assets/img/blog/0004/magnet.png)\n\n<br>\n\n## Firefox\n[Webseite](https://www.mozilla.org/de/firefox/new/)  \n\n```bash\nbrew install --cask firefox\n```","contentEN":"When setting up a new or freshly installed Mac, the first step, of course, is to install all development tools.  \nFirst, here's a list of my favorite tools. Then, there are also tips and terminal commands that make life easier.  \nThe list is by no means exhaustive, and everyone has different favorites. It's likely that my setup has already changed again with some tools. \n<br>\n\n## Terminal\n- brew\n- iTerm2\n- ohmyzsh\n- Powerlevel10k\n\n<br>  \n\n## Developer tools\n- JetBrains Toolbox\n- Intellij\n- Visual Studio Code\n- Redis\n- PostgreSQL (Postgres.app)\n- NodeJS\n- Angular\n- Fork (git client)\n- LanScan\n- Docker\n- Colima (Docker runtime)\n- Atom\n- Insomnia\n- draw.io\n\n<br>\n\n## Tools\n- Alfred\n- Magnet\n- Firefox\n\n<br>\n\n# Setup\n## brew  \n[Webpage](https://brew.sh)  \n\nThe package manager for macOS. We will use it to install almost all other tools.  \n\n``` bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```  \n<br>\n\n**Hint**: On Macs with Apple Silicon, brew is now installed here:  \n`/opt/homebrew/bin`  \ninstead of the old location on Intel Macs:  \n`/usr/local/bin`  \nSince the new path is not in PATH, it needs to be set.\nSimply add the following line to ~/.zshrc:  \n```\nexport PATH=/opt/homebrew/bin:$PATH\n```\n\n<br>\n\n## iTerm  \n[Webpage](https://iterm2.com)  \n\nMy favorite terminal\n\n```bash\nbrew install --cask iterm2\n```\n\n<br>\n\n## ohmyzsh\n[Webpage](https://ohmyz.sh/)  \n\nFramework for ZSH configuration\n\n```bash\nsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n\n<br>\n\n## Powerlevel10k & zsh Tweaks \n<br>\n\n### Powerlevel10k\n[Webpage](https://github.com/romkatv/powerlevel10k)  \n\nclone repository:\n\n```bash\ngit clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k\n```\n\nEdit zsh `~/.zshrc` config and set the following for ZSH_THEME: `ZSH_THEME=\"powerlevel10k/powerlevel10k\"`\n\nStart a new terminal session the apply the changes.\nYou will be prompted to configure powerlevel10k in the new session. The configuration can be run again using the command `p10k configure`.\n\n<br>\n\n### Natural Text Editing\nTo be able to move in text via option/alt + → or ← by jumping over words, it is necessary to set the following setting in iterm:  \n\n<br>\n\niTerm->Preferences...->Profiles->Keys->Key Mappings->Presets...->Natural Text Editing\n\n<br>\n\n### zsh autosuggestions\nInstallation:\n```bash\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n```\n\nEdit `~/.zshrc` and add `zsh-autosuggestions` to plugins:  \n`plugins=(zsh-autosuggestions)` \n\n![zsh-syntax-highlighting](/assets/img/blog/0004/zsh-autosuggestions.png)\n\n<br>\n\n## Redis\n[Webpage](https://redis.io/)\n\n<br>\n\n### Install Redis\n```bash\nbrew install redis\n```\n\n<br>\n\n### Run Redis as foreground process\n\n```bash\nredis-server\n```\n\n<br>\n\n### Redis service commands\n\nUsually uses **port 6379**  \n\n<br>\n\n**Start Redis service**\n\n```bash\nbrew services start redis\n```\n\n**Stop Redis service**\n\n```bash\nbrew services stop redis\n```\n\n**Restart Redis service**\n\n```bash\nbrew services restart redis\n```\n\n<br>\n\n## PostgreSQL (Postgres.app)\n[Webpage](https://postgresapp.com/)  \nEasiest way to get a PostgreSQL database running locally on your Mac without much setup.  \nDownload available on the website.\n\n<br>\n\n## NodeJS\n[Webpage](https://nodejs.org)  \n\nInstalls the latest version of `node` and `npm`. This is __not__ the LTS version!\n\n```bash\nbrew install node\n```\n\nTo install the LTS version check the NodeJS [Webpage](https://nodejs.org) for the correct version. Install this version with the following command. The __X__ must be replaced with the major version of the LTS release. e.g. `node@12`\n\n```bash\nbrew install node@X\n```\n\nTo switch between different NodeJS versions use the following commands:  \n\n```bash\n# Unlink current version\nbrew unlink node\n\n# Install new version\nbrew install node@X\n\n# Link new version\nbrew link node@X\n\n# Test if it worked\nnode --version\n```\n\n<br>\n\n## Angular\n[Webpage](https://angular.io)\n\nInstallation\n\n```bash\nnpm install -g @angular/cli\n```\n\n<br>\n\n## JetBrains Toolbox\n[Webpage](https://www.jetbrains.com/toolbox-app/)\n\nJetBrains Toolbox lives in the macOS menu bar. This tool can easily install, switch between versions and update all JetBrains tools. Additionally, it shows an overview of the last used projects in all IDEs and lets you open them from one place in the correct IDE with one click.  \n\n![jetbrains toolbox](/assets/img/blog/0004/toolbox.png)\n\n```bash\nbrew install --cask jetbrains-toolbox\n```\n\n<br>\n\n## Visual Studio Code\n[Webseite](https://code.visualstudio.com/)  \n\n```bash\nbrew install --cask visual-studio-code\n```\n\n<br>\n\n## Fork\n[Webpage](https://git-fork.com)  \n\nNice to look at and fully featured git client.\n\n```bash\nbrew install --cask fork\n```\n\n<br>\n\n## LanScan\n[Webpage](https://apps.apple.com/de/app/lanscan/id472226235?mt=12)  \n\nSmall tool to scan your LAN for devices. Download from the App Store.  \n\n![lanscan](/assets/img/blog/0004/lanscan.png)\n\n<br>\n\n## Docker\n[Webpage](https://www.docker.com/)  \n\n```bash\nbrew install docker\n```\n\n### Colima - Docker runtime\n[Webpage](https://github.com/abiosoft/colima)  \n\n```bash\nbrew install colima\n```\n\n<br>\n\n## Atom\n[Webpage](https://atom.io/)  \n\nLightweight text edit tool with huge potential expansion options through plugins. Nice to edit textfiles without the need to boot a whole IDE.  \n\n```bash\nbrew install --cask atom\n```\n\n<br>\n\n## Insomnia\n[Webpage](https://insomnia.rest)  \n\nHTTP request tool for REST APIs. Similar to Postman.  \n\n```bash\nbrew install --cask insomnia\n```\n\n<br>\n\n## draw.io\n[Webpage](https://drawio-app.com/)  \n\nTool for drawing all kinds of diagrams.  \n\n```bash\nbrew install --cask drawio\n```\n\n<br>\n\n## MacDown\n[Webpage](https://macdown.uranusjr.com)  \n\nMarkdown editor.\n\n```bash\nbrew install --cask macdown\n```\n\n<br>\n\n## Alfred\n[Webpage](https://www.alfredapp.com)  \n\nSpotlight alternative with more features.\n\n```bash\nbrew install --cask alfred\n```\n\n<br>\n\n## Magnet\n[Webpage](https://apps.apple.com/de/app/magnet/id441258766?mt=12) 3,99€ - Download in Mac App Store  \n<br>\nMagnet lives in the masOS menu bar and expands the window management functionality of macOS. I really like the shortcuts and the ability to not only divide my desktop by half but also by thirds.  \n\n![magnet](/assets/img/blog/0004/magnet.png)\n\n<br>\n\n## Firefox\n[Webpage](https://www.mozilla.org/de/firefox/new/)  \n\n```bash\nbrew install --cask firefox\n```","tags":["Mac","macOS","Tools","Setup"],"projects":[]},{"id":9,"titleDE":"BPM Detector V1.1.0","titleEN":"BPM Detector V1.1.0","descDE":"Update auf Version 1.1.0","descEN":"Update to version 1.1.0","date":"2021-09-30T14:34:08.700Z","contentDE":"Das erste Update des BPM Detectors bietet einige Neuerungen für gratis Benutzer und für den in App Kauf. Es gibt eine neue Einstellung für die Genauigkeit der BPM Berechnung. Des Weiteren sind neue Funktionen zur App Individualisierung verfügbar, inklusive eines Einhorn-Modus 🦄.  \nDie App ist jetzt zusätzlich zu Englisch auch in der Deutschen Sprache verfügbar.\n\n![App IMG](/assets/img/blog/0009/1.png)\n\n# Changelog 1.1.0\n30.09.2021\n<br>\n<br>\n- **Gratis Funktionen**\n- Genauigkeitseinstellung hinzugefügt\n- Deutsche Sprache hinzugefügt\n<br><br>\n- **In App Kauf Funktionen**\n- Zufällige BPM Text Farbe\n- Zufällige Hintergrundfarbe\n- Einhorn-Modus 🦄\n\n\n<br>\n\n## Links\n- Projekt: [BPM Tapper](/bpmdetector)\n- [App Store](https://apps.apple.com/app/bpm-detector/id1586439275)","contentEN":"The first BPM detector update brings a couple of new features for free and in app purchase users.  A new setting is added to tweak the accuracy of the BPM calculation. New settings for more app individualization were also added, including a unicorn mode 🦄.  \nThe app is now also available in German.\n\n\n![App IMG](/assets/img/blog/0009/1.png)\n\n\n# Changelog 1.1.0\n30.09.2021\n<br>\n<br>\n- **Free features**\n- Added accuracy setting\n- Added German translation\n<br><br>\n- **In App Purchase features**\n- Random BPM color on tap\n- Random Background color on tap\n- Unicorn mode 🦄\n\n\n<br>\n\n## Links\n- Project: [BPM detector](/bpmdetector)\n- [App Store](https://apps.apple.com/app/bpm-detector/id1586439275)","tags":["iOS"," App"," SwiftUI"],"projects":[]},{"id":8,"titleDE":"BPM Detector V1.0.0","titleEN":"BPM Detector V1.0.0","descDE":"Erstveröffentlichung im App Store","descEN":"Initial App Store release","date":"2021-09-20T14:34:08.700Z","contentDE":"Nach vielen he­r­um­pro­bie­ren mit Swift und SwiftUI habe ich heute meine erste App im Apple App Store veröffentlicht.  \nDer BPM Detector ist eine App zum Erkennen der BPM (Beats pro Minute) eines Liedes über das Tippen eines Buttons in der App im Takt des Liedes.  \nDamit die App nicht zu simpel und langweilig ist, gibt es Statistiken und einen in App Kauf, um das Design der App anpassen zu können. Auf [Projektseite](/projects/6) findet sich noch mehr Informationen über die App.\n\n![App IMG](/assets/img/blog/0008/1.png)\n\n# Changelog 1.0.0\n20.09.2021\n<br>\n<br>\n- Erster App Store Release\n<br><br>\n- **Gratis Funktionen**\n- Tippen zur BPM Erkennung\n- Basis Schwarz/Weiß Design\n- Keine Designindividualisierung\n- Statistiken:\n- _Takte getippt_\n- _Durchschnittliche  BPM_\n- _Höchste BPM_\n<br><br>\n- **In App Kauf Funktionen**\n- Hintergundfarbe\n- BPM Farbe\n- Tap Button Farbe\n- Tap Button Text Farbe\n- Zufällige Button Farbe\n\n\n<br>\n\n## Links\n- Projekt: [BPM Tapper](/bpmdetector)\n- [App Store](https://apps.apple.com/app/bpm-detector/id1586439275)","contentEN":"After playing around with Swift and SwiftUI for a while, I published my first app on the Apple App Store today.  \nThe BPM Detector is an app for the detecting the BPM (beats per minute) of a song, by tapping a button in sync with the beat of a song. To not only publish an app with only this single feature, I added statistics and an in app purchase to customize the look of the app.  \nYou can find more information about the app on the [project page](/projects/6).\n\n![App IMG](/assets/img/blog/0008/1.png)\n\n# Changelog 1.0.0\n20.09.2021\n<br>\n<br>\n- First App Store release \n<br><br>\n- **Free features**\n- Tap for BPM\n- Basic black & white theme\n- No customizations\n- Statistics:\n- _Total Taps_\n- _Average BPM_\n- _Highest BPM_\n<br><br>\n- **In App Purchase features**\n- Background color\n- BPM color\n- Tap button color\n- Tap button text color\n- Random tap button color on tap\n\n\n<br>\n\n## Links\n- Project: [BPM detector](/bpmdetector)\n- [App Store](https://apps.apple.com/app/bpm-detector/id1586439275)","tags":["iOS"," App"," SwiftUI"],"projects":[]},{"id":3,"titleDE":"Angular Deployment mit NGINX","titleEN":"Angular Deployment with NGINX","descDE":"NGINX Konfiguration für Angular Projekte","descEN":"NGINX config for Angular projects","date":"2020-09-01T00:00:00.700Z","contentDE":"Das Angular Projekt ist fertig fürs Deployment. Wie geht es jetzt weiter? Es sollte, aus Sicherheit und Performance Gründen, auf keinen Fall der in Angular eingebaute Webserver verwendet werden! \n\n![Angular warning message](/assets/img/blog/0003/1.png)\n\nDeshalb verwenden wir NGINX. Zum Deployment sind nur 3 einfache Schritte notwendig:  \n<br>\n\n# 1. Angular Projekt kompilieren\n\nDas Projekt mit folgendem Befehl kompilieren:\n\n```bash\nnpm i\nng build --prod\n```  \n<br>\n\n# 2. Gebauten Code auf production Server kopieren\n\nDer gebaute Code befindet sich im Root Verzeichnis des Projektes unter`dist/PROJEKTNAME`. In dem Ordner befindet sich genau eine .html Datei. Die `index.html`. Diese ist wichtig im späteren Schritt.  \nDer gesamte Ordner muss nun auf den production Server kopiert werden. Ob man das mit `scp` Befehl oder per FTP macht ist dabei egal.  \n<br>\n\n# 3. NGINX Konfiguration\n\n```nginx\nserver {\n    listen 80;\n\n    server_name example.com www.example.com;\n    index index.html;\n    root /your/path/to/your/application/dist/PROJEKTNAME;\n\n    location / {\n        try_files $uri$args $uri$args/ /index.html;\n    }\n}\n```\n\nWir gehen die Bedeutung der einzelnen Zeilen von oben nach unten durch:  \n<br>\n\n`listen 80;` Der NGINX Server bindet unsere Angular Seite an den HTTP Port 80  \n<br>\n\n`index index.html;` Gibt die index Datei, in diesem Fall index.html, an welche geserved wird, wenn keine Datei explizit angegeben wird.  \n<br>  \n\n`server_name example.com www.example.com;` Sagt NGINX nur auf Anfragen zu hören die über die Domain example.com eingehen  \n<br>\n\n`root /your/path/to/your/application/dist/PROJEKTNAME;` Sagt NGINX wo auf dem Server der kompilierte Angular Code liegt  \n<br>\n\n`try_files $uri$args $uri$args/ /index.html;`  \nDiese Zeile ist die Interessanteste der Konfiguration. Sie beschreibt wie mit Anfragen umgegangen werden soll. Um den Sinn der Zeile zu verstehen muss kurz darauf eingegangen werden wie Angular Code kompiliert. Es werden nicht wie bei traditionellen statischen Webseiten fertige .html Dateien ausgeliefert. Es gibt nur eine sehr minimalistische `index.html` Datei, welche alle notwendigen .js und .css Dateien nachlädt. Das heißt damit auch, wenn ein Benutzer auf z.B. `example.com/impressum` zugreifen will, dass diese Datei nicht existiert. Wir wollen aber nicht, dass der Benutzer einen Fehler angezeigt bekommt. Daher sorgt diese Zeile dafür, dass versucht wird die angegebene Datei zu finden (`try_files`). Ist das nicht erfolgreich wird statt eines `404` Fehlers einfach die `index.html` gesendet, welche die Seite lädt und sich um den Rest kümmert.  \n<br>\n\nDas war auch schon die gesamte Konfiguration.  \n\n<br>\n\n## Technologien\n- **NGINX**   \n- **Angular**\n\n<br>\n","contentEN":"The new Angular project is done, and it is time for deployment. How do we continue now? You should never use the built in Angular webserver for deployment! For security and performance reasons.\n\n![Angular warning message](/assets/img/blog/0003/1.png)\n\nThat's why we will use NGINX. For Angular deployment you just need to follow these 3 easy steps:  \n<br>\n\n# 1. Compile Angular project\n\nCompile the Angular project with the following command:\n\n```bash\nnpm i\nng build --prod\n```  \n<br>\n\n# 2. Copy compiled code to production server\n\nThe compiled code is located in the root directory of your project \nin `dist/PROJECTNAME`. This directory contains exactly one .html file. the `index.html` file. This will be important later.  \nThe whole directory needs to be copied to the production server. \nIt does not matter how you upload your code. You could use `scp`, FTP or something else.  \n<br>\n\n# 3. NGINX configuration\n\n```nginx\nserver {\n    listen 80;\n\n    server_name example.com www.example.com;\n    index index.html;\n    root /your/path/to/your/application/dist/PROJECTNAME;\n\n    location / {\n        try_files $uri$args $uri$args/ /index.html;\n    }\n}\n```\n\nWe will go through each line of the configuration:  \n<br>\n\n`listen 80;` The NGINX server binds the Angular Page to the HTTP Port 80  \n<br>\n\n`server_name example.com www.example.com;` Tells NGINX to only listen to requests that are made via the domain example.com  \n<br>\n\n`index index.html;` Describes the index file, in this example index.html, that will be served when no file is explicitly requested.  \n<br>  \n\n`root /your/path/to/your/application/dist/PROJECTNAME;` Tells NGINX the location of the Angular code on the server  \n<br>\n\n`try_files $uri$args $uri$args/ /index.html;`  \nThis is the most interesting line in the configuration. It tells describes how to handle requests. To be able to understand this line I must explain first how Angular compiles code. Angular applications don’t serve premade static .html files. Instead only one very small `index.html` file will be served, which loads all necessary .js .css files. In conclusion that means, that if a user tries to load for example `example.com/imprint`, the file will not exist. We don’t want the user to run into an error.  \nThat’s why this line is trying to find files (`try_files`) matching the url. If that is not successful it will fall back to serving the `index.html` files instead of throwing an `404` error. The `index.html` will handle the url NGINX was unable to find.  \n<br>\n\n\nThat’s all for Angular deployment configuration.\n\n<br>\n\n## Technologies\n- **NGINX**   \n- **Angular**\n\n<br>\n","tags":["NGINX","Angular","Deployment"],"projects":[]},{"id":2,"titleDE":"NGINX Frontend und Backend Routing","titleEN":"NGINX frontend and backend routing","descDE":"3 Methoden Frontend und Backend Traffic auf dem selben Server mit NGINX zu routen","descEN":"3 ways to route frontend and backend traffic on the same server with NGINX","date":"2020-08-31T00:00:00.700Z","contentDE":"Viele Webseiten bestehen heutzutage aus mehreren Teilen und Services. Selbst die simpelsten wie [diese](/) bestehen aus einem Frontend Service und einem Backend Service. Diese Services müssen alle über eine Adresse aus dem Internet erreichbar sein, damit die Seite funktionieren kann. Bei kleinen Seiten laufen front und backend oft auf demselben Server und haben daher auch dieselbe IP Adresse. Daher ist eine Zuordnung notwendig, welcher traffic zu welchem Service geleitet werden soll. Mit NGINX ist das leicht möglich und es gibt 3 Methoden das umzusetzen.  \n<br>\n## Voraussetzungen\n<br>\n\n- Für alle 3 Methoden ist eine oder mehrere Domains notwendig bei denen der A Record auf den Server, mit NGINX, gesetzt werden kann und neue Subdomains erstellt werden können.  \n- NGINX ist mit _Server Blocks_ auf dem Server eingerichtet. Eine gute Anleitung dafür gibt es [hier](https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-20-04). Server Blocks werden dabei in _Schritt 5_ erklärt.\n<br><br>\n\n# 1. Verschiedene Pfade für verschiedene Services\n**Frontend Domain:** `example.com/*`  \n**Backend Domain:** `example.com/api/*`  \n<br>\n\nFür diesen Ansatz ist nur eine Domain und ein Server Block in der NGINX config notwendig. Richten Sie für Ihre Domain (hier im Beispiel **example.com**) einen A Record für die Domain selbst und die Subdomain **www.** ein, die auf den Server zeigt. Die Subdomain www. ist notwendig, damit die Seite erreichbar ist, wenn Benutzer diese mit und ohne www. im Browser eingeben.  \n<br>\n\nDen NGINX Serverblock richten sie folgendermaßen ein:\n\n```nginx\nserver {\n        index index.html;\n\n        server_name example.com www.example.com;\n\n        location / {\n                 root /var/www/your_frontend_html_code;\n        }\n\n        location /api {\n                proxy_pass http://127.0.0.1:1234;\n        }\n}\n```\n<br>\n\nIn dem Beispiel wird nun der Traffic der über die Domain example.com bei NGINX ankommt an `/var/www/your_frontend_html_code` weitergeleitet. Mit der Ausnahme von Pfaden auf `/api/*` matchen. Diese werden an einen Service auf localhost, der auf dem Port **1234** läuft, weitergeleitet.  \n<br>  \n\n# 2. Verschiedene Subdomains für verschiede Services\n**Frontend Domain:** `example.com/*`  \n**Backend Domain:** `api.example.com/*`  \n<br>\n\nFür diesen Ansatz ist wieder nur eine Domain notwendig, aber 2 Server Blöcke. Richten sie für Ihre Domain wieder den A Record wie bei Methode 1. ein. Zusätzlich muss eine Subdomain, in diesem Beispiel `api.example.com`, eingerichtet werden mit demselben A Record wie die Hauptdomain.  \n<br>\n\nDie NGINX Serverblöcke sehen folgendermaßen aus:\n```nginx\nserver {\n        index index.html;\n\n        server_name example.com www.example.com;\n\n        location / {\n                 root /var/www/your_frontend_html_code;\n        }\n}\n\nserver {\n\n        location / {\n                proxy_pass http://127.0.0.1:1234;\n        }\n\n        server_name api.example.com www.api.example.com;\n}\n```  \n<br>\n\nIn dem Beispiel wird nun der Traffic der über die Domain example.com bei NGINX ankommt an `/var/www/your_frontend_html_code` weitergeleitet. Auch der Pfad `example.com/api/*`. Der backend Service, der auf Port 1234 läuft ist über die Subdomain `api.example.com/*` erreichbar.  \n<br>\n\n\n# 3. Verschiedene Domains für verschiedene Services\n**Frontend Domain:** `example.com/*`  \n**Backend Domain:** `exampleapi.com/*`  \n<br>\n\nFür den 3ten Ansatz sind 2 Domains und 2 Server Blöcke notwendig.\nEs muss wie in Methode 1. ein A Record eingerichtet werden. Diesmal aber für beide Domains.  \n<br>\n\nDie NGINX Serverblöcke sehen folgendermaßen aus:\n```nginx\nserver {\n        index index.html;\n\n        server_name example.com www.example.com;\n\n        location / {\n                 root /var/www/your_frontend_html_code;\n        }\n}\n\nserver {\n\n        location / {\n                proxy_pass http://127.0.0.1:1234;\n        }\n\n        server_name exampleapi.com www.exampleapi.com;\n}\n```  \nIn dem Beispiel wird nun der Traffic der über die Domain `example.com` bei NGINX ankommt an `/var/www/your_frontend_html_code` weitergeleitet.  \nDer Traffic der über die Domain `exampleapi.com` wird an den backenden Service auf Port 1234 weitergeleitet.\n\n---\n\nWelche der 3 Methoden die richtige ist lässt sich aber nicht pauschal sagen und hängt vom Projekt, der Serverstruktur und dem eigenen Geschmack ab.  \nEs ist auch möglich die Beispiele mit mehr Services zu verwenden. Es müssen nur mehr Domains und Serverblöcke hinzugefügt werden.\n\n<br>\n\n## Technologien\n- **NGINX**   \n\n<br>\n","contentEN":"Many webpages today consist of multiple parts and services. Even simple pages like [this one](/) are using a frontend and backend service. All these services need to be reachable via an address over the internet, for the site to be functional. For small sites the frontend and backend services can run on the same server with the same IP address. If that is the case in your project, it is necessary to route the incoming traffic to the correct service.  \nThere are 3 methods to solve this problem with NGINX.  \n<br>\n## Requirements\n<br>\n\n- Every method needs one or more domains where you are able to create subdomains and set A Records for those domains.\n- NGINX is setup on the server using _Server Blocks_. A good manual to setup a Server with NGINX can be found [here](https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-20-04). Server blocks are explained in _step 5_.  \n<br><br>\n\n# 1. Different paths for different services\n**Frontend Domain:** `example.com/*`  \n**Backend Domain:** `example.com/api/*`  \n<br>\n\nFor this method we only need one domain and one server block in the NGINX config. Setup your domain (here **example.com**) to point the A Record to your server running NGINX and your services. Also, setup a subdomain **www.** with the same A Record. The subdomain is necessary when users try to reach your side using the full domain starting with `www.`  \n<br>\n\nThe NGINX server block looks like this:  \n\n```nginx\nserver {\n        index index.html;\n\n        server_name example.com www.example.com;\n\n        location / {\n                 root /var/www/your_frontend_html_code;\n        }\n\n        location /api {\n                proxy_pass http://127.0.0.1:1234;\n        }\n}\n```\n<br>\n\nIn the example the traffic via the domain example.com will be redirected to `/var/www/your_frontend_html_code`.  \nExcept the traffic matching `/api/*`. That traffic will be redirected to a service running on localhost on port **1234**.  \n\n<br>\n\n# 2. Different subdomains for different services\n**Frontend Domain:** `example.com/*`  \n**Backend Domain:** `api.example.com/*`  \n<br>\n\nFor this method we, again, only need one domain, but we will need 2 server blocks. Setup your Domain again like in method 1. Additionally, we need to setup a subdomain. In this example `api.example.com`. Set the A Record to the same IP as the base domain.  \n<br>\n\nThe NGINX server blocks look like this:  \n```nginx\nserver {\n        index index.html;\n\n        server_name example.com www.example.com;\n\n        location / {\n                 root /var/www/your_frontend_html_code;\n        }\n}\n\nserver {\n\n        location / {\n                proxy_pass http://127.0.0.1:1234;\n        }\n\n        server_name api.example.com www.api.example.com;\n}\n```  \n<br>\n\nIn this example the traffic via example.com is redirected to `/var/www/your_frontend_html_code`. Including the path `example.com/api/*`.  \nThe backend service running on port 1234 is reachable via the subdomain `api.example.com/*`.  \n\n<br>\n\n\n# 3. Different domains for different services\n**Frontend Domain:** `example.com/*`  \n**Backend Domain:** `exampleapi.com/*`  \n<br>\n\nThe third method uses 2 domains and 2 server blocks. You need to setup your domain the same way we did in method 1 but for both domains.\n\n<br>\n\nThe NGINX server blocks look like this:  \n```nginx\nserver {\n        index index.html;\n\n        server_name example.com www.example.com;\n\n        location / {\n                 root /var/www/your_frontend_html_code;\n        }\n}\n\nserver {\n\n        location / {\n                proxy_pass http://127.0.0.1:1234;\n        }\n\n        server_name exampleapi.com www.exampleapi.com;\n}\n```  \n\nIn this example the traffic via `example.com` is redirected to `/var/www/your_frontend_html_code`.  \nThe backend service running on port 1234 is reachable via the second domain `exampleapi.com`.\n\n---\n\nWhich method is the best to use for your project is not that easy to tell. It depends on your project, your server infrastructure and your taste.  \nIt is also possible to use these examples with more services. Just add more server blocks and domains.\n\n<br>\n\n## Technologies\n- **NGINX**   \n\n<br>\n","tags":["NGINX","API","Service","Routing"],"projects":[]},{"id":1,"titleDE":"iTunes Mediathek zu Apple Music konvertieren","titleEN":"iTunes library to Apple Music conversion","descDE":"Konvertierung der iTunes Mediathek zur neuen Apple Music Mediathek","descEN":"How to convert your old library from iTunes the the new macOS Music app","date":"2020-01-12T00:00:00.700Z","contentDE":"Nach dem Update auf macOS Catalina (macOS 10.15) von einer früheren Version von macOS sollte die Migration der iTunes Mediathek automatisch erfolgreich gewesen sein. Alle Playlisten und Album Cover sind wo sie hingehören.  \n<br>\nEin Problem, auf das ich etwas später nach der macOS Migration gestoßen bin, ist das meine Backups nicht mit der Veränderung der neuen Apple Music Mediathek zusammenarbeiten. Meine Daten sichere ich mit Timemachine. Für meine Musik habe ich nach einer Neuinstallation von macOS, oder dem Wechsel zu einem neuen Mac, einfach den iTunes Ordner kopiert und voila, alle meine Musik war genau wie vorher. (Also **nicht** mein System von Timemachine **automatisch** wiederherstellen lassen) Zu meiner Überraschung klappt das ab Catalina leider nur bedingt gut.\n\n![Music broken covers](/assets/img/blog/0001/1.jpg)\n\nDanach waren nämlich alle cover verschwunden.\nAber warum ist das so?  \n<br>\nBei der Umstellung von iTunes auf Apple Music wurde der Speicherort von der Albumcover Dateien verändert.  \n<br>\nIn meiner Recherche habe ich herausgefunden, dass es 3 Wege gibt seine Musikbibliothek korrekt mit Bildern in die neue Musik App zu importieren:  \n\n<br>  \n\n# 1. Migration durch macOS Upgrade\n\nDies ist der einfachste Weg eine bestehende iTunes Bibliothek zu Apple Music zu konvertieren. Beim Upgrade auf macOS Catalina werden die Bilder automatisch zum neuen Speicherort verschoben.\n\n\n<br>  \n\n# 2. Manuell von einem Backup der alten iTunes Ordnerstruktur\n\n1. Kopiere den backup iTunes Ordner nach `~/Music/iTunes`\n2. Die Taste option/alt gedrückt halten und Apple Musik öffnen\n3. Bei der Abfrage \"_Musikbibliothek auswählen_\" klicken und  `~/Music/iTunes/iTunes Library.itl` auswählen\n4. Fertig\n\n![Music lib selection](/assets/img/blog/0001/3.png)\n\n<br>  \n \n# 3. Migration von bereits migrierten iTunes/Musik Ordner von Catalina zu Catalina\n\nNach der Migration befinden sich unter `~/Music` die beiden Ordner `~/Music/iTunes` & `~/Music/Music`. Beide müssen in einem Backup gesichert werden. Die Bilddateien für die Alben befinden sich aber leider in keinem dieser Ordner. Deshalb muss ein weiterer Ordner gesichert werden:\n<br>  \n`~/Library/Containers/com.apple.AMPArtworkAgent/Data/Documents`\n<br>  \nZum Wiederherstellen sind folgende Schritte notwendig:  \n<br>  \n1. Kopieren des backup iTunes Ordners nach `~/Music/iTunes`\n2. Kopieren des backup Music Ordners nach `~/Music/Music`\n3. Kopieren und überschreiben des _Documents_ Ordners durch das backup `~/Library/Containers/com.apple.AMPArtworkAgent/Data/Documents`\n4. Die Taste option/alt gedrückt halten und Apple Music öffnen\n5. Bei der Abfrage \"Musikbibliothek auswählen\" klicken und `~/Music/Music/Music Library.musiclibrary` auswählen\n6. Fertig\n\n<br>\n<br>\n\n**Alle 3 Methoden sollten zu einer Music App führen die so aussieht:**\n\n![Music working covers](/assets/img/blog/0001/2.jpg)\n","contentEN":"If you just upgraded to Catalina (macOS 10.15) from an older version of macOS the migration of your iTunes library probably went fine, and all playlists songs and albums covers are the way they are supposed to be.  \n<br>\nBut if you are using Timemachine or a different backup method to restore your library to a new computer or after a reinstall of macOS, by copy and pasting the iTunes folder manually (**Not** letting Timemachine restore your Mac **automatically**), Apple music will no longer find images for your album covers.\n\n![Music broken covers](/assets/img/blog/0001/1.jpg)\n\nThat's because during the change from iTunes to Apple Music they changed the location of those images.  \n<br>\nIn my research I found 3 ways to import your Music collection properly with album art to the new Music app:  \n\n<br>\n\n# 1. Migration during macOS Upgrade\n\nThis is the easiest way to convert an iTunes library to Apple Music. Just upgrade your computer with an existing iTunes library to macOS Catalina or higher and you are done. All images will be moved to the new location.\n\n<br>\n\n# 2. Manually from a backup with iTunes folder structure\n\n1. Copy backup iTunes directory to `~/Music/iTunes`\n2. Press and hold option/alt and open Apple Music\n3. Select \"_Choose Library..._\" and select `~/Music/iTunes/iTunes Library.itl`\n4. Done\n\n![Music lib selection](/assets/img/blog/0001/3.png)\n\n<br>  \n\n# 3. Migrate already migrated iTunes/Music directory from Catalina to Catalina\n\nAfter migrating to Apple Music, the directory `~/Music` contains the 2 directories `~/Music/iTunes` & `~/Music/Music`. Both directories need to be included in a backup. But the album art files are in neither of those 2 directories. That's why we also need to back up a third directory:\n<br>  \n`~/Library/Containers/com.apple.AMPArtworkAgent/Data/Documents`\n<br>  \nTo restore the library, we need the following steps:\n<br>  \n1. Copy the backup iTunes directory to `~/Music/iTunes`\n2. Copy the backup Music directory to `~/Music/Music`\n3. Copy and overwrite the _Documents_ directory with the backup`~/Library/Containers/com.apple.AMPArtworkAgent/Data/Documents`\n4. Press and hold option/alt and open Apple Music\n5. Select \"_Choose Library..._\" and select `~/Music/Music/Music Library.musiclibrary`\n6. Done\n\n<br>\n<br>\n\n**All 3 methods should result in an Music app looking like this:**\n\n![Music working covers](/assets/img/blog/0001/2.jpg)","tags":["macOS","iTunes","Music"],"projects":[]}]